I"<p>vuex 的 github ，入口文件展示给我们的就是核心Store和常用的工具方法，</p>

<pre><code class="language-js">export default {
    Store,
    install,
    version: '__VERSION__',
    mapState,
    mapMutations,
    mapGetters,
    mapActions,
    createNamespacedHelpers
}

</code></pre>
<h2 id="vuex挂载">vuex挂载</h2>

<p>vuex 是通过插件的方式将vuex实例挂载到vue上，</p>
<pre><code class="language-js">  Vue.use(Vuex);
</code></pre>

<p>install 中vue 1.x 和 2.x 注入store方式稍微有点区别：1.x 使用init，2.x使用vue混入方式,在beforeCreate生命周期中影响每个组件。</p>

<pre><code class="language-js">
// 这个函数实现保证将store影响到每个组件，并且保证store的唯一性，进行集中托管
function vuexInit () {
    const options = this.$options
    // root 时将options中store赋值给$store
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    // 非root 时获取父组件的$store给当前组建的$store
    } else if (options.parent &amp;&amp; options.parent.$store) {
      this.$store = options.parent.$store
    }
  }

</code></pre>

<h2 id="store">Store</h2>

<p>进入store文件，我们看一下状态管理类Store的实现</p>

<pre><code class="language-js">export class Store {
  constructor (options = {}) {
    // 如果之前没有挂载到Vue, 自动挂载一次
    if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      // 断言函数 将一定应该出现的却没有的情况抛出，这是一种值得学习的写法
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `store must be called with the new operator.`)
    }

    const {
      plugins = [],
      strict = false
    } = options

    // 标记state值改变是否通过mutation提交
    this._committing = false
    // 存储store Action
    this._actions = Object.create(null)
    // 存储Action订阅者
    this._actionSubscribers = []
    // 存储store Mutation
    this._mutations = Object.create(null)
    // 存储store Getters
    this._wrappedGetters = Object.create(null)
    // 模块化结构，生成模块树
    this._modules = new ModuleCollection(options)
    // 存储命名空间模块
    this._modulesNamespaceMap = Object.create(null)
    // 用来存储所有对 mutation 变化的订阅者
    // 有点奇怪命名为什么没有像actionSubscribers格式，起成: mutationSubscribers, 难道是后来加的actionSubscribers?
    this._subscribers = []
    // vm
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    // 给当前实例添加两个属性dispatch和commit，并修改this指向当前实例，
    // 每个实例下都有自己的dispatch和commit, 实例之间没有相互影响
    // 防止vue应用程序恶意更改this指向 this.$store.dispatch.call(this, type, payload);
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // 启用严格模式
    this.strict = strict
    // root state 
    const state = this._modules.root.state

    //init root module.
    // 初始化root模块
    // this also recursively registers all sub-modules 
    // 递归注册所有子模块
    // and collects all module getters inside this._wrappedGetters
    // 同时收集各个模块的Getter
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for the reactivity
    // 初始化store vm, 同时响应数据变化
    // (also registers _wrappedGetters as computed properties)
    // 同时挂载Getter到计算属性
    resetStoreVM(this, state)
    // apply plugins
    plugins.forEach(plugin =&gt; plugin(this))

    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
    // 将vuex数据变化展示到vue-devtools
    if (useDevtools) {
      devtoolPlugin(this)
    }
  }
  ... 
}
</code></pre>

<h3 id="commit实现">commit实现</h3>

<p>组件中使用commit传递两个参数，type和payload,例如：</p>
<pre><code class="language-js">  this.$store.commit('updateState', {
    state: true
  })
</code></pre>
<p>源码中commit的实现也是比较简单的，从收集的mutations中找出对应的事件类型，依次触发，然后再执行mutations中的订阅函数</p>

<pre><code class="language-js">
commit (_type, _payload, _options) {
    // 格式校验
    const {
      type,
      payload,
      options
    } = unifyObjectStyle(_type, _payload, _options)

    const mutation = { type, payload }
    // 从mutations集合中取出对应的type下的事件
    const entry = this._mutations[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }
    //依次触发commit
    this._withCommit(() =&gt; {
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
    // commit完成之后再调用订阅事件
    this._subscribers.forEach(sub =&gt; sub(mutation, this.state))

    if (
      process.env.NODE_ENV !== 'production' &amp;&amp;
      options &amp;&amp; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
  }
</code></pre>

:ET